<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Rive ASCII Blob Converter</title>
<style>
  :root {
    --bg: #1a1a2e;
    --surface: #16213e;
    --border: #0f3460;
    --accent: #e94560;
    --accent-hover: #ff6b81;
    --text: #eee;
    --text-dim: #888;
    --success: #4ecca3;
    --mono: "Cascadia Code", "Fira Code", "Consolas", "Courier New", monospace;
  }
  * { box-sizing: border-box; margin: 0; padding: 0; }
  body {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
    background: var(--bg);
    color: var(--text);
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 24px;
  }
  h1 {
    font-size: 1.6rem;
    margin-bottom: 4px;
    letter-spacing: 1px;
  }
  .subtitle {
    color: var(--text-dim);
    font-size: 0.85rem;
    margin-bottom: 24px;
  }
  .app {
    width: 100%;
    max-width: 800px;
  }

  /* Footer */
  .footer {
    margin-top: 40px;
    padding: 16px 0;
    text-align: center;
    font-size: 0.8rem;
    color: var(--text-dim);
    width: 100%;
    max-width: 800px;
  }
  .footer a {
    color: var(--text-dim);
    text-decoration: none;
    transition: color 0.2s;
  }
  .footer a:hover {
    color: var(--accent);
  }
  .footer .author-name {
    color: var(--text);
    font-weight: 500;
  }

  /* Tabs */
  .tabs {
    display: flex;
    gap: 0;
    margin-bottom: 20px;
  }
  .tab {
    flex: 1;
    padding: 12px 16px;
    background: var(--surface);
    border: 1px solid var(--border);
    color: var(--text-dim);
    cursor: pointer;
    font-size: 0.95rem;
    text-align: center;
    transition: all 0.2s;
  }
  .tab:first-child { border-radius: 8px 0 0 8px; }
  .tab:last-child { border-radius: 0 8px 8px 0; }
  .tab.active {
    background: var(--border);
    color: var(--text);
    border-color: var(--accent);
  }
  .tab:hover:not(.active) { background: #1a2a4a; }

  /* Drop zone */
  .drop-zone {
    border: 2px dashed var(--border);
    border-radius: 12px;
    padding: 48px 24px;
    text-align: center;
    cursor: pointer;
    transition: all 0.2s;
    margin-bottom: 20px;
    background: var(--surface);
  }
  .drop-zone:hover, .drop-zone.drag-over {
    border-color: var(--accent);
    background: #1a2a4a;
  }
  .drop-zone.has-file {
    border-color: var(--success);
    border-style: solid;
  }
  .drop-zone-icon { font-size: 2.5rem; margin-bottom: 8px; }
  .drop-zone-text { color: var(--text-dim); font-size: 0.9rem; }
  .drop-zone-file {
    color: var(--success);
    font-weight: 600;
    font-size: 1rem;
    margin-top: 4px;
  }
  .drop-zone input[type="file"] { display: none; }

  /* Source info bar */
  .source-info {
    font-size: 0.85rem;
    color: var(--text-dim);
    margin-bottom: 12px;
    padding: 8px 12px;
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 6px;
    display: none;
  }
  .source-info.show { display: block; }
  .source-info span { color: var(--text); font-weight: 500; }

  /* Controls */
  .controls {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 12px;
    margin-bottom: 8px;
  }
  .control-group {
    display: flex;
    flex-direction: column;
    gap: 4px;
  }
  .control-group label {
    font-size: 0.8rem;
    color: var(--text-dim);
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }
  .control-group input[type="number"] {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 6px;
    padding: 8px 12px;
    color: var(--text);
    font-size: 0.95rem;
    outline: none;
    transition: border-color 0.2s;
    width: 100%;
  }
  .control-group input:focus {
    border-color: var(--accent);
  }
  .control-group input::placeholder {
    color: #555;
  }

  /* Lock aspect ratio row */
  .lock-row {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-bottom: 20px;
    padding: 0 2px;
  }
  .lock-row label {
    font-size: 0.85rem;
    color: var(--text-dim);
    cursor: pointer;
    user-select: none;
    display: flex;
    align-items: center;
    gap: 6px;
  }
  .lock-row input[type="checkbox"] {
    accent-color: var(--accent);
    width: 16px;
    height: 16px;
    cursor: pointer;
  }
  .lock-icon {
    font-size: 0.9rem;
  }

  /* Buttons */
  .actions {
    display: flex;
    gap: 10px;
    margin-bottom: 20px;
  }
  .btn {
    flex: 1;
    padding: 12px 24px;
    border: none;
    border-radius: 8px;
    font-size: 0.95rem;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s;
  }
  .btn:disabled {
    opacity: 0.4;
    cursor: not-allowed;
  }
  .btn-primary {
    background: var(--accent);
    color: #fff;
  }
  .btn-primary:hover:not(:disabled) { background: var(--accent-hover); }
  .btn-secondary {
    background: var(--surface);
    color: var(--text);
    border: 1px solid var(--border);
  }
  .btn-secondary:hover:not(:disabled) { background: #1a2a4a; }

  /* Status */
  .status {
    padding: 12px 16px;
    border-radius: 8px;
    margin-bottom: 20px;
    font-size: 0.9rem;
    display: none;
  }
  .status.show { display: block; }
  .status.info { background: #0f3460; color: #8ec5fc; }
  .status.success { background: #1a3a2a; color: var(--success); }
  .status.error { background: #3a1a1a; color: #ff6b6b; }

  /* Preview */
  .preview-container {
    background: #0d0d1a;
    border: 1px solid var(--border);
    border-radius: 8px;
    overflow: hidden;
    display: none;
  }
  .preview-container.show { display: block; }
  .preview-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 8px 12px;
    background: var(--surface);
    border-bottom: 1px solid var(--border);
    font-size: 0.8rem;
    color: var(--text-dim);
  }
  .preview-content {
    padding: 8px;
    overflow-x: auto;
    max-height: 70vh;
    overflow-y: auto;
  }
  .preview-content pre {
    font-family: var(--mono);
    font-size: 6px;
    line-height: 1;
    letter-spacing: 0px;
    color: var(--success);
    white-space: pre;
    margin: 0;
  }

  /* Playback controls */
  .playback-controls { display: none; align-items: center; gap: 8px; }
  .playback-controls.show { display: flex; }
  .play-pause-btn {
    background: none; border: 1px solid var(--border); border-radius: 4px;
    color: var(--text); cursor: pointer; font-size: 0.85rem; padding: 2px 8px;
    transition: all 0.2s; line-height: 1.2;
  }
  .play-pause-btn:hover { border-color: var(--accent); color: var(--accent); }
  .frame-counter { font-size: 0.8rem; color: var(--text-dim); font-variant-numeric: tabular-nums; }

  /* Preview scale control */
  .scale-control { display: flex; align-items: center; gap: 8px; padding: 6px 12px; background: var(--surface); border-bottom: 1px solid var(--border); }
  .scale-control label { font-size: 0.75rem; color: var(--text-dim); text-transform: uppercase; letter-spacing: 0.5px; white-space: nowrap; }
  .scale-slider { flex: 1; height: 4px; -webkit-appearance: none; appearance: none; background: #0f3460; border-radius: 2px; outline: none; cursor: pointer; }
  .scale-slider::-webkit-slider-thumb {
    -webkit-appearance: none; appearance: none;
    width: 12px; height: 12px; border-radius: 50%;
    background: var(--accent); border: none; cursor: pointer;
  }
  .scale-slider::-moz-range-thumb {
    width: 12px; height: 12px; border-radius: 50%;
    background: var(--accent); border: none; cursor: pointer;
  }
  .scale-value {
    width: 48px; background: var(--bg); border: 1px solid var(--border); border-radius: 4px;
    color: var(--text); font-size: 0.8rem; text-align: center; padding: 2px 4px; outline: none;
  }
  .scale-value:focus { border-color: var(--accent); }

  /* Timeline scrubber */
  .timeline { display: none; padding: 6px 12px 10px; background: var(--surface); border-top: 1px solid var(--border); }
  .timeline.show { display: block; }
  .timeline input[type="range"] {
    width: 100%; height: 6px; -webkit-appearance: none; appearance: none;
    background: #0f3460; border-radius: 3px; outline: none; cursor: pointer;
  }
  .timeline input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none; appearance: none;
    width: 14px; height: 14px; border-radius: 50%;
    background: var(--accent); border: none; cursor: pointer;
  }
  .timeline input[type="range"]::-moz-range-thumb {
    width: 14px; height: 14px; border-radius: 50%;
    background: var(--accent); border: none; cursor: pointer;
  }

  /* Progress bar */
  .progress-bar { height: 4px; background: #0f3460; border-radius: 2px; margin-bottom: 8px; overflow: hidden; }
  .progress-fill { height: 100%; background: var(--accent); transition: width 0.1s; }

  /* Spinner */
  .spinner {
    display: inline-block;
    width: 16px;
    height: 16px;
    border: 2px solid #fff3;
    border-top-color: #fff;
    border-radius: 50%;
    animation: spin 0.6s linear infinite;
    margin-right: 8px;
    vertical-align: middle;
  }
  @keyframes spin { to { transform: rotate(360deg); } }
</style>
</head>
<body>

<h1>Rive ASCII Blob Converter</h1>
<p class="subtitle">Convert images and videos to .blob files for Rive ASCII art</p>

<div class="app">
  <!-- Mode Tabs -->
  <div class="tabs">
    <div class="tab active" data-mode="image" onclick="switchMode('image')">Single Image</div>
    <div class="tab" data-mode="video" onclick="switchMode('video')">Video / Animation</div>
  </div>

  <!-- Drop Zone -->
  <div class="drop-zone" id="dropZone">
    <div class="drop-zone-icon">&#128196;</div>
    <div class="drop-zone-text" id="dropText">Drag & drop a file here, or click to browse</div>
    <div class="drop-zone-file" id="dropFile"></div>
    <input type="file" id="fileInput">
  </div>

  <!-- Source Info -->
  <div class="source-info" id="sourceInfo"></div>

  <!-- Controls -->
  <div class="controls">
    <div class="control-group">
      <label>Columns</label>
      <input type="number" id="cols" value="100" min="1" max="500">
    </div>
    <div class="control-group">
      <label>Rows</label>
      <input type="number" id="rows" value="56" min="1" max="500">
    </div>
    <div class="control-group" id="fpsGroup" style="display:none">
      <label>FPS (0 = auto)</label>
      <input type="number" id="fps" value="0" min="0" max="120" placeholder="Auto-detect">
    </div>
    <div class="control-group" id="maxFramesGroup" style="display:none">
      <label>Max Frames (0 = all)</label>
      <input type="number" id="maxFrames" value="0" min="0" placeholder="All frames">
    </div>
  </div>

  <!-- Lock Aspect Ratio -->
  <div class="lock-row">
    <label>
      <input type="checkbox" id="lockAspect" checked>
      <span class="lock-icon">&#128279;</span> Lock aspect ratio
    </label>
  </div>

  <!-- Action Buttons -->
  <div class="actions">
    <button class="btn btn-secondary" id="previewBtn" onclick="doPreview()" disabled>Preview</button>
    <button class="btn btn-primary" id="convertBtn" onclick="doConvert()" disabled>Convert & Download</button>
  </div>

  <!-- Status -->
  <div class="status" id="status"></div>

  <!-- Preview -->
  <div class="preview-container" id="previewContainer">
    <div class="preview-header">
      <span>ASCII Preview</span>
      <span class="playback-controls" id="playbackControls">
        <button class="play-pause-btn" id="playPauseBtn" onclick="togglePlayback()">&#9208;</button>
        <span class="frame-counter" id="frameCounter"></span>
      </span>
      <span id="previewInfo"></span>
    </div>
    <div class="scale-control">
      <label>Scale</label>
      <input type="range" class="scale-slider" id="scaleSlider" min="1" max="20" value="6" step="0.5">
      <input type="number" class="scale-value" id="scaleValue" min="1" max="20" value="6" step="0.5">
      <label>px</label>
    </div>
    <div class="preview-content">
      <pre id="previewText"></pre>
    </div>
    <div class="timeline" id="timeline">
      <input type="range" id="timelineSlider" min="0" max="0" value="0">
    </div>
  </div>
</div>

<script>
let currentMode = "image";
let selectedFile = null;

// Source dimensions (pixels) — set when a file is loaded
let sourceWidth = 0;
let sourceHeight = 0;
let aspectRatio = 0;  // width / height

// Animation playback state
let animFrames = [];      // Array of ASCII text strings (one per frame)
let animFps = 24;
let animTimer = null;     // setInterval ID
let animFrame = 0;        // current frame index
let isPlaying = false;

const dropZone = document.getElementById("dropZone");
const fileInput = document.getElementById("fileInput");
const dropText = document.getElementById("dropText");
const dropFile = document.getElementById("dropFile");
const previewBtn = document.getElementById("previewBtn");
const convertBtn = document.getElementById("convertBtn");
const statusEl = document.getElementById("status");
const previewContainer = document.getElementById("previewContainer");
const previewText = document.getElementById("previewText");
const previewInfo = document.getElementById("previewInfo");
const sourceInfoEl = document.getElementById("sourceInfo");
const colsInput = document.getElementById("cols");
const rowsInput = document.getElementById("rows");
const lockAspect = document.getElementById("lockAspect");
const playbackControls = document.getElementById("playbackControls");
const playPauseBtn = document.getElementById("playPauseBtn");
const frameCounter = document.getElementById("frameCounter");
const timelineEl = document.getElementById("timeline");
const timelineSlider = document.getElementById("timelineSlider");
const scaleSlider = document.getElementById("scaleSlider");
const scaleValueInput = document.getElementById("scaleValue");

const ASCII_RAMP = " .:-=+*#%@";  // 10 chars, index 0-9

const IMAGE_ACCEPT = ".png,.jpg,.jpeg,.bmp,.tiff,.tif,.webp";
const VIDEO_ACCEPT = ".mp4,.mov,.avi,.mkv,.webm,.gif";

// --- Aspect Ratio Logic ---

function setSourceDimensions(w, h, extraInfo) {
  sourceWidth = w;
  sourceHeight = h;
  aspectRatio = w / h;

  // Show source info
  let info = `Source: <span>${w} x ${h}</span> px`;
  if (extraInfo) info += ` &nbsp;|&nbsp; ${extraInfo}`;
  sourceInfoEl.innerHTML = info;
  sourceInfoEl.classList.add("show");

  // Auto-adjust rows to match aspect ratio, keeping cols as-is
  applyAspectToRows();
}

function clearSourceDimensions() {
  sourceWidth = 0;
  sourceHeight = 0;
  aspectRatio = 0;
  sourceInfoEl.classList.remove("show");
}

function applyAspectToRows() {
  if (aspectRatio <= 0) return;
  const cols = parseInt(colsInput.value) || 100;
  const newRows = Math.max(1, Math.round(cols / aspectRatio));
  rowsInput.value = newRows;
}

function applyAspectToCols() {
  if (aspectRatio <= 0) return;
  const rows = parseInt(rowsInput.value) || 60;
  const newCols = Math.max(1, Math.round(rows * aspectRatio));
  colsInput.value = newCols;
}

// When cols changes and lock is on → recalculate rows
colsInput.addEventListener("input", () => {
  if (lockAspect.checked && aspectRatio > 0) {
    applyAspectToRows();
  }
});

// When rows changes and lock is on → recalculate cols
rowsInput.addEventListener("input", () => {
  if (lockAspect.checked && aspectRatio > 0) {
    applyAspectToCols();
  }
});

// When lock is toggled ON → snap rows to current aspect ratio
lockAspect.addEventListener("change", () => {
  if (lockAspect.checked && aspectRatio > 0) {
    applyAspectToRows();
  }
});

// --- Detect image dimensions client-side ---

function detectImageDimensions(file) {
  return new Promise((resolve) => {
    const img = new Image();
    img.onload = () => {
      resolve({ width: img.naturalWidth, height: img.naturalHeight });
      URL.revokeObjectURL(img.src);
    };
    img.onerror = () => {
      resolve(null);
      URL.revokeObjectURL(img.src);
    };
    img.src = URL.createObjectURL(file);
  });
}

// --- Detect video dimensions via server ---

async function detectVideoDimensions(file) {
  const formData = new FormData();
  formData.append("file", file);
  try {
    const resp = await fetch("/dimensions/video", { method: "POST", body: formData });
    if (!resp.ok) return null;
    return await resp.json();
  } catch {
    return null;
  }
}

// --- Mode switching ---

function switchMode(mode) {
  stopCurrentAnimation();
  currentMode = mode;
  document.querySelectorAll(".tab").forEach(t => t.classList.toggle("active", t.dataset.mode === mode));

  const isVideo = mode === "video";
  document.getElementById("fpsGroup").style.display = isVideo ? "" : "none";
  document.getElementById("maxFramesGroup").style.display = isVideo ? "" : "none";
  fileInput.accept = isVideo ? VIDEO_ACCEPT : IMAGE_ACCEPT;

  // Reset
  clearFile();
  hideStatus();
  previewContainer.classList.remove("show");

  dropText.textContent = isVideo
    ? "Drag & drop a video or GIF here, or click to browse"
    : "Drag & drop an image here, or click to browse";
}

function clearFile() {
  stopCurrentAnimation();
  selectedFile = null;
  dropFile.textContent = "";
  dropZone.classList.remove("has-file");
  previewBtn.disabled = true;
  convertBtn.disabled = true;
  fileInput.value = "";
  clearSourceDimensions();
}

async function setFile(file) {
  selectedFile = file;
  dropFile.textContent = file.name + " (" + formatSize(file.size) + ")";
  dropZone.classList.add("has-file");
  previewBtn.disabled = false;
  convertBtn.disabled = false;

  // Detect dimensions
  if (currentMode === "image") {
    const dims = await detectImageDimensions(file);
    if (dims) {
      setSourceDimensions(dims.width, dims.height);
    }
  } else {
    // Video — ask server
    showStatusHTML('<span class="spinner"></span> Reading video info...', "info");
    const info = await detectVideoDimensions(file);
    hideStatus();
    if (info && !info.error) {
      const extra = `<span>${info.source_fps}</span> fps, <span>${info.total_frames}</span> frames`;
      setSourceDimensions(info.width, info.height, extra);
    }
  }
}

function formatSize(bytes) {
  if (bytes < 1024) return bytes + " B";
  if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + " KB";
  return (bytes / (1024 * 1024)).toFixed(1) + " MB";
}

// Drop zone events
dropZone.addEventListener("click", () => {
  fileInput.accept = currentMode === "video" ? VIDEO_ACCEPT : IMAGE_ACCEPT;
  fileInput.click();
});

fileInput.addEventListener("change", (e) => {
  if (e.target.files.length > 0) {
    setFile(e.target.files[0]);
    previewContainer.classList.remove("show");
  }
});

dropZone.addEventListener("dragover", (e) => {
  e.preventDefault();
  dropZone.classList.add("drag-over");
});

dropZone.addEventListener("dragleave", () => {
  dropZone.classList.remove("drag-over");
});

dropZone.addEventListener("drop", (e) => {
  e.preventDefault();
  dropZone.classList.remove("drag-over");
  if (e.dataTransfer.files.length > 0) {
    setFile(e.dataTransfer.files[0]);
    previewContainer.classList.remove("show");
  }
});

function showStatus(message, type) {
  statusEl.textContent = message;
  statusEl.className = "status show " + type;
}

function showStatusHTML(html, type) {
  statusEl.innerHTML = html;
  statusEl.className = "status show " + type;
}

function hideStatus() {
  statusEl.className = "status";
}

function getParams() {
  return {
    cols: parseInt(colsInput.value) || 100,
    rows: parseInt(rowsInput.value) || 60,
    fps: parseInt(document.getElementById("fps").value) || 0,
    maxFrames: parseInt(document.getElementById("maxFrames").value) || 0,
  };
}

// --- Client-side video frame extraction (for animated preview) ---

async function extractVideoFramesClient(file, cols, rows, fps, maxFrames, onProgress) {
  const video = document.createElement("video");
  video.muted = true;
  video.preload = "auto";
  const url = URL.createObjectURL(file);
  video.src = url;

  await new Promise((resolve, reject) => {
    video.onloadeddata = resolve;
    video.onerror = () => reject(new Error("Failed to load video"));
  });

  const duration = video.duration;
  const actualFps = fps > 0 ? fps : 24;
  let totalFrames = Math.floor(duration * actualFps);
  if (maxFrames > 0 && totalFrames > maxFrames) totalFrames = maxFrames;
  if (totalFrames > 500) totalFrames = 500;
  if (totalFrames < 1) totalFrames = 1;

  const canvas = document.createElement("canvas");
  canvas.width = cols;
  canvas.height = rows;
  const ctx = canvas.getContext("2d", { willReadFrequently: true });
  ctx.imageSmoothingEnabled = true;
  ctx.imageSmoothingQuality = "high";

  const frames = [];

  for (let i = 0; i < totalFrames; i++) {
    const time = i / actualFps;
    if (time > duration) break;

    video.currentTime = time;
    await new Promise(r => { video.onseeked = r; });

    ctx.drawImage(video, 0, 0, cols, rows);
    const rgba = ctx.getImageData(0, 0, cols, rows).data;
    const brightness = new Uint8Array(cols * rows);
    for (let p = 0; p < cols * rows; p++) {
      const r = rgba[p * 4], g = rgba[p * 4 + 1], b = rgba[p * 4 + 2];
      brightness[p] = Math.round(0.299 * r + 0.587 * g + 0.114 * b);
    }
    frames.push(brightness);

    if (onProgress) onProgress(i + 1, totalFrames);
    await new Promise(r => setTimeout(r, 0));
  }

  URL.revokeObjectURL(url);
  return { frames, fps: actualFps };
}

function brightnessToAscii(brightness, cols, rows) {
  const lines = [];
  for (let row = 0; row < rows; row++) {
    let line = "";
    for (let col = 0; col < cols; col++) {
      const b = brightness[row * cols + col];
      const idx = Math.floor(b * 9 / 255);
      line += ASCII_RAMP[idx];
    }
    lines.push(line);
  }
  return lines.join("\n");
}

// --- Animation playback ---

function stopCurrentAnimation() {
  if (animTimer) { clearInterval(animTimer); animTimer = null; }
  isPlaying = false;
  animFrames = [];
  animFrame = 0;
  playbackControls.classList.remove("show");
  timelineEl.classList.remove("show");
}

function showFrame(index) {
  animFrame = index;
  previewText.textContent = animFrames[animFrame];
  frameCounter.textContent = (animFrame + 1) + " / " + animFrames.length;
  timelineSlider.value = animFrame;
}

function startAnimation() {
  if (animFrames.length <= 1) return;
  isPlaying = true;
  playPauseBtn.innerHTML = "&#9208;"; // pause icon
  animTimer = setInterval(() => {
    showFrame((animFrame + 1) % animFrames.length);
  }, 1000 / animFps);
}

function stopAnimation() {
  if (animTimer) { clearInterval(animTimer); animTimer = null; }
  isPlaying = false;
  playPauseBtn.innerHTML = "&#9654;"; // play icon
}

function togglePlayback() {
  if (isPlaying) stopAnimation();
  else startAnimation();
}

// Timeline scrubber events
timelineSlider.addEventListener("input", () => {
  if (isPlaying) stopAnimation();
  showFrame(parseInt(timelineSlider.value));
});

// Preview scale events
function applyScale(val) {
  const size = Math.max(1, Math.min(20, parseFloat(val) || 6));
  scaleSlider.value = size;
  scaleValueInput.value = size;
  previewText.style.fontSize = size + "px";
  requestAnimationFrame(fixPreviewAspect);
}
scaleSlider.addEventListener("input", () => applyScale(scaleSlider.value));
scaleValueInput.addEventListener("input", () => applyScale(scaleValueInput.value));

// --- Preview ---

async function doPreview() {
  if (!selectedFile) return;
  stopCurrentAnimation();

  const params = getParams();
  const cols = Math.max(1, Math.min(params.cols, 500));
  const rows = Math.max(1, Math.min(params.rows, 500));

  previewBtn.disabled = true;
  showStatusHTML('<span class="spinner"></span> Generating preview...', "info");

  try {
    if (currentMode === "video") {
      // Extract all frames client-side for animated preview
      const fps = params.fps > 0 ? params.fps : 24;
      const maxFrames = params.maxFrames > 0 ? params.maxFrames : 0;

      const { frames, fps: actualFps } = await extractVideoFramesClient(
        selectedFile, cols, rows, fps, maxFrames,
        (current, total) => {
          const pct = Math.round(current / total * 100);
          showStatusHTML(
            `<div class="progress-bar"><div class="progress-fill" style="width:${pct}%"></div></div>`
            + `<span class="spinner"></span> Extracting frame ${current} / ${total}...`,
            "info"
          );
        }
      );

      if (frames.length === 0) {
        showStatus("Error: No frames extracted", "error");
        previewBtn.disabled = false;
        return;
      }

      // Convert all frames to ASCII text
      animFrames = frames.map(b => brightnessToAscii(b, cols, rows));
      animFps = actualFps;
      animFrame = 0;

      // Show first frame
      previewInfo.textContent = cols + "x" + rows;
      previewContainer.classList.add("show");
      showFrame(0);
      requestAnimationFrame(fixPreviewAspect);

      // Show playback controls, timeline, and auto-play
      if (animFrames.length > 1) {
        playbackControls.classList.add("show");
        timelineSlider.max = animFrames.length - 1;
        timelineSlider.value = 0;
        timelineEl.classList.add("show");
        startAnimation();
      }
    } else {
      // Single image — use server-side preview
      const formData = new FormData();
      formData.append("file", selectedFile);
      formData.append("cols", cols);
      formData.append("rows", rows);

      const resp = await fetch("/preview", { method: "POST", body: formData });
      const data = await resp.json();

      if (data.error) {
        showStatus("Error: " + data.error, "error");
        previewBtn.disabled = false;
        return;
      }

      previewText.textContent = data.preview;
      previewInfo.textContent = data.cols + "x" + data.rows;
      previewContainer.classList.add("show");
      requestAnimationFrame(fixPreviewAspect);
    }
    hideStatus();
  } catch (e) {
    showStatus("Request failed: " + e.message, "error");
  }

  previewBtn.disabled = false;
}

async function doConvert() {
  if (!selectedFile) return;

  const params = getParams();
  const formData = new FormData();
  formData.append("file", selectedFile);
  formData.append("cols", params.cols);
  formData.append("rows", params.rows);

  const endpoint = currentMode === "video" ? "/convert/video" : "/convert/image";

  if (currentMode === "video") {
    formData.append("fps", params.fps);
    formData.append("max_frames", params.maxFrames);
  }

  convertBtn.disabled = true;
  previewBtn.disabled = true;
  showStatusHTML('<span class="spinner"></span> Converting...', "info");

  try {
    const resp = await fetch(endpoint, { method: "POST", body: formData });

    if (!resp.ok) {
      const data = await resp.json();
      showStatus("Error: " + (data.error || "Unknown error"), "error");
      convertBtn.disabled = false;
      previewBtn.disabled = false;
      return;
    }

    const blob = await resp.blob();
    const filename = currentMode === "video" ? "ascii_sequence.blob" : "ascii_data.blob";

    // Trigger download
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);

    showStatus("Done! Downloaded " + filename + " (" + formatSize(blob.size) + ")", "success");
  } catch (e) {
    showStatus("Request failed: " + e.message, "error");
  }

  convertBtn.disabled = false;
  previewBtn.disabled = false;
}

// --- Measure monospace character cell & fix preview aspect ratio ---

function fixPreviewAspect() {
  // Create an offscreen measurement element with the same font as the preview
  const measure = document.createElement("span");
  measure.style.fontFamily = getComputedStyle(previewText).fontFamily;
  measure.style.fontSize = getComputedStyle(previewText).fontSize;
  measure.style.lineHeight = getComputedStyle(previewText).lineHeight;
  measure.style.letterSpacing = getComputedStyle(previewText).letterSpacing;
  measure.style.position = "absolute";
  measure.style.visibility = "hidden";
  measure.style.whiteSpace = "pre";
  measure.textContent = "M";  // single character
  document.body.appendChild(measure);

  const charWidth = measure.getBoundingClientRect().width;
  const charHeight = measure.getBoundingClientRect().height;
  document.body.removeChild(measure);

  // We want each cell to look square, so scaleY = charWidth / charHeight
  if (charHeight > 0 && charWidth > 0) {
    const ratio = charWidth / charHeight;
    previewText.style.transformOrigin = "top left";
    previewText.style.transform = `scaleY(${ratio})`;

    // Shrink the container to match the visually-scaled content
    // so there's no empty gap below
    const previewContent = previewText.parentElement;
    const actualHeight = previewText.scrollHeight * ratio;
    previewContent.style.height = actualHeight + 16 + "px"; // +16 for padding
  }
}

// Initialize
switchMode("image");
</script>

<footer class="footer">
  Made by <a href="https://www.behance.net/pkoik" target="_blank" rel="noopener"><span class="author-name">Sergey Vodyanov</span></a> &middot; 2026
</footer>

</body>
</html>
