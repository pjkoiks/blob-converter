<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Rive ASCII Blob Converter</title>
<style>
  :root {
    --bg: #1a1a2e;
    --surface: #16213e;
    --border: #0f3460;
    --accent: #e94560;
    --accent-hover: #ff6b81;
    --text: #eee;
    --text-dim: #888;
    --success: #4ecca3;
    --mono: "Cascadia Code", "Fira Code", "Consolas", "Courier New", monospace;
  }
  * { box-sizing: border-box; margin: 0; padding: 0; }
  body {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
    background: var(--bg);
    color: var(--text);
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 24px;
  }
  h1 {
    font-size: 1.6rem;
    margin-bottom: 4px;
    letter-spacing: 1px;
  }
  .subtitle {
    color: var(--text-dim);
    font-size: 0.85rem;
    margin-bottom: 24px;
  }
  .app {
    width: 100%;
    max-width: 800px;
  }

  /* Tabs */
  .tabs { display: flex; gap: 0; margin-bottom: 20px; }
  .tab {
    flex: 1; padding: 12px 16px; background: var(--surface);
    border: 1px solid var(--border); color: var(--text-dim);
    cursor: pointer; font-size: 0.95rem; text-align: center; transition: all 0.2s;
  }
  .tab:first-child { border-radius: 8px 0 0 8px; }
  .tab:last-child { border-radius: 0 8px 8px 0; }
  .tab.active { background: var(--border); color: var(--text); border-color: var(--accent); }
  .tab:hover:not(.active) { background: #1a2a4a; }

  /* Drop zone */
  .drop-zone {
    border: 2px dashed var(--border); border-radius: 12px; padding: 48px 24px;
    text-align: center; cursor: pointer; transition: all 0.2s;
    margin-bottom: 20px; background: var(--surface);
  }
  .drop-zone:hover, .drop-zone.drag-over { border-color: var(--accent); background: #1a2a4a; }
  .drop-zone.has-file { border-color: var(--success); border-style: solid; }
  .drop-zone-icon { font-size: 2.5rem; margin-bottom: 8px; }
  .drop-zone-text { color: var(--text-dim); font-size: 0.9rem; }
  .drop-zone-file { color: var(--success); font-weight: 600; font-size: 1rem; margin-top: 4px; }
  .drop-zone input[type="file"] { display: none; }

  /* Source info bar */
  .source-info {
    font-size: 0.85rem; color: var(--text-dim); margin-bottom: 12px;
    padding: 8px 12px; background: var(--surface);
    border: 1px solid var(--border); border-radius: 6px; display: none;
  }
  .source-info.show { display: block; }
  .source-info span { color: var(--text); font-weight: 500; }

  /* Controls */
  .controls { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-bottom: 8px; }
  .control-group { display: flex; flex-direction: column; gap: 4px; }
  .control-group label { font-size: 0.8rem; color: var(--text-dim); text-transform: uppercase; letter-spacing: 0.5px; }
  .control-group input[type="number"] {
    background: var(--surface); border: 1px solid var(--border); border-radius: 6px;
    padding: 8px 12px; color: var(--text); font-size: 0.95rem;
    outline: none; transition: border-color 0.2s; width: 100%;
  }
  .control-group input:focus { border-color: var(--accent); }
  .control-group input::placeholder { color: #555; }

  /* Lock aspect ratio */
  .lock-row { display: flex; align-items: center; gap: 8px; margin-bottom: 20px; padding: 0 2px; }
  .lock-row label { font-size: 0.85rem; color: var(--text-dim); cursor: pointer; user-select: none; display: flex; align-items: center; gap: 6px; }
  .lock-row input[type="checkbox"] { accent-color: var(--accent); width: 16px; height: 16px; cursor: pointer; }
  .lock-icon { font-size: 0.9rem; }

  /* Buttons */
  .actions { display: flex; gap: 10px; margin-bottom: 20px; }
  .btn {
    flex: 1; padding: 12px 24px; border: none; border-radius: 8px;
    font-size: 0.95rem; font-weight: 600; cursor: pointer; transition: all 0.2s;
  }
  .btn:disabled { opacity: 0.4; cursor: not-allowed; }
  .btn-primary { background: var(--accent); color: #fff; }
  .btn-primary:hover:not(:disabled) { background: var(--accent-hover); }
  .btn-secondary { background: var(--surface); color: var(--text); border: 1px solid var(--border); }
  .btn-secondary:hover:not(:disabled) { background: #1a2a4a; }

  /* Status */
  .status { padding: 12px 16px; border-radius: 8px; margin-bottom: 20px; font-size: 0.9rem; display: none; }
  .status.show { display: block; }
  .status.info { background: #0f3460; color: #8ec5fc; }
  .status.success { background: #1a3a2a; color: var(--success); }
  .status.error { background: #3a1a1a; color: #ff6b6b; }
  .progress-bar { height: 4px; background: #0f3460; border-radius: 2px; margin-bottom: 8px; overflow: hidden; }
  .progress-fill { height: 100%; background: var(--accent); transition: width 0.1s; }

  /* Preview */
  .preview-container { background: #0d0d1a; border: 1px solid var(--border); border-radius: 8px; overflow: hidden; display: none; }
  .preview-container.show { display: block; }
  .preview-header {
    display: flex; justify-content: space-between; align-items: center;
    padding: 8px 12px; background: var(--surface);
    border-bottom: 1px solid var(--border); font-size: 0.8rem; color: var(--text-dim);
  }
  .preview-content { padding: 8px; overflow-x: auto; max-height: 500px; overflow-y: auto; }
  .preview-content pre {
    font-family: var(--mono); font-size: 6px; line-height: 1;
    letter-spacing: 0px; color: var(--success); white-space: pre; margin: 0;
  }

  /* Spinner */
  .spinner {
    display: inline-block; width: 16px; height: 16px;
    border: 2px solid #fff3; border-top-color: #fff;
    border-radius: 50%; animation: spin 0.6s linear infinite;
    margin-right: 8px; vertical-align: middle;
  }
  @keyframes spin { to { transform: rotate(360deg); } }
</style>
</head>
<body>

<h1>Rive ASCII Blob Converter</h1>
<p class="subtitle">Convert images and videos to .blob files for Rive ASCII art — runs entirely in your browser</p>

<div class="app">
  <div class="tabs">
    <div class="tab active" data-mode="image" onclick="switchMode('image')">Single Image</div>
    <div class="tab" data-mode="video" onclick="switchMode('video')">Video / Animation</div>
  </div>

  <div class="drop-zone" id="dropZone">
    <div class="drop-zone-icon">&#128196;</div>
    <div class="drop-zone-text" id="dropText">Drag & drop a file here, or click to browse</div>
    <div class="drop-zone-file" id="dropFile"></div>
    <input type="file" id="fileInput">
  </div>

  <div class="source-info" id="sourceInfo"></div>

  <div class="controls">
    <div class="control-group">
      <label>Columns</label>
      <input type="number" id="cols" value="100" min="1" max="500">
    </div>
    <div class="control-group">
      <label>Rows</label>
      <input type="number" id="rows" value="56" min="1" max="500">
    </div>
    <div class="control-group" id="fpsGroup" style="display:none">
      <label>FPS (0 = auto ~24)</label>
      <input type="number" id="fps" value="0" min="0" max="120" placeholder="Auto ~24">
    </div>
    <div class="control-group" id="maxFramesGroup" style="display:none">
      <label>Max Frames (0 = all)</label>
      <input type="number" id="maxFrames" value="0" min="0" placeholder="All frames">
    </div>
  </div>

  <div class="lock-row">
    <label>
      <input type="checkbox" id="lockAspect" checked>
      <span class="lock-icon">&#128279;</span> Lock aspect ratio
    </label>
  </div>

  <div class="actions">
    <button class="btn btn-secondary" id="previewBtn" onclick="doPreview()" disabled>Preview</button>
    <button class="btn btn-primary" id="convertBtn" onclick="doConvert()" disabled>Convert & Download</button>
  </div>

  <div class="status" id="status"></div>

  <div class="preview-container" id="previewContainer">
    <div class="preview-header">
      <span>ASCII Preview</span>
      <span id="previewInfo"></span>
    </div>
    <div class="preview-content">
      <pre id="previewText"></pre>
    </div>
  </div>
</div>

<script>
// ============================================================
// CORE PROCESSING — Image & Video → Brightness → Binary Blob
// ============================================================

const ASCII_RAMP = " .:-=+*#%@";  // 10 chars, index 0-9

/**
 * Load an image file, resize to cols×rows, return grayscale brightness bytes.
 * Uses PIL-compatible luminance: 0.299*R + 0.587*G + 0.114*B
 */
function extractBrightness(file, cols, rows) {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.onload = () => {
      const canvas = document.createElement("canvas");
      canvas.width = cols;
      canvas.height = rows;
      const ctx = canvas.getContext("2d", { willReadFrequently: true });
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = "high";
      ctx.drawImage(img, 0, 0, cols, rows);
      const rgba = ctx.getImageData(0, 0, cols, rows).data;
      const brightness = new Uint8Array(cols * rows);
      for (let i = 0; i < cols * rows; i++) {
        const r = rgba[i * 4], g = rgba[i * 4 + 1], b = rgba[i * 4 + 2];
        brightness[i] = Math.round(0.299 * r + 0.587 * g + 0.114 * b);
      }
      URL.revokeObjectURL(img.src);
      resolve(brightness);
    };
    img.onerror = () => { URL.revokeObjectURL(img.src); reject(new Error("Failed to load image")); };
    img.src = URL.createObjectURL(file);
  });
}

/**
 * Extract brightness from a single video frame at the given time (seconds).
 */
function extractVideoFrame(file, cols, rows, timeSec) {
  return new Promise((resolve, reject) => {
    const video = document.createElement("video");
    video.muted = true;
    video.preload = "auto";

    video.onloadeddata = () => {
      video.currentTime = Math.min(timeSec, video.duration);
    };
    video.onseeked = () => {
      const canvas = document.createElement("canvas");
      canvas.width = cols;
      canvas.height = rows;
      const ctx = canvas.getContext("2d", { willReadFrequently: true });
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = "high";
      ctx.drawImage(video, 0, 0, cols, rows);
      const rgba = ctx.getImageData(0, 0, cols, rows).data;
      const brightness = new Uint8Array(cols * rows);
      for (let i = 0; i < cols * rows; i++) {
        const r = rgba[i * 4], g = rgba[i * 4 + 1], b = rgba[i * 4 + 2];
        brightness[i] = Math.round(0.299 * r + 0.587 * g + 0.114 * b);
      }
      URL.revokeObjectURL(video.src);
      resolve(brightness);
    };
    video.onerror = () => { URL.revokeObjectURL(video.src); reject(new Error("Failed to load video")); };
    video.src = URL.createObjectURL(file);
  });
}

/**
 * Extract all frames from a video. Returns {frames: Uint8Array[], fps: number}.
 * onProgress(current, total) is called after each frame for UI updates.
 */
async function extractVideoFrames(file, cols, rows, fps, maxFrames, onProgress) {
  const video = document.createElement("video");
  video.muted = true;
  video.preload = "auto";
  const url = URL.createObjectURL(file);
  video.src = url;

  await new Promise((resolve, reject) => {
    video.onloadeddata = resolve;
    video.onerror = () => reject(new Error("Failed to load video"));
  });

  const duration = video.duration;
  const actualFps = fps > 0 ? fps : 24;
  let totalFrames = Math.floor(duration * actualFps);
  if (maxFrames > 0 && totalFrames > maxFrames) totalFrames = maxFrames;
  if (totalFrames > 500) totalFrames = 500;
  if (totalFrames < 1) totalFrames = 1;

  const canvas = document.createElement("canvas");
  canvas.width = cols;
  canvas.height = rows;
  const ctx = canvas.getContext("2d", { willReadFrequently: true });
  ctx.imageSmoothingEnabled = true;
  ctx.imageSmoothingQuality = "high";

  const frames = [];

  for (let i = 0; i < totalFrames; i++) {
    const time = i / actualFps;
    if (time > duration) break;

    video.currentTime = time;
    await new Promise(r => { video.onseeked = r; });

    ctx.drawImage(video, 0, 0, cols, rows);
    const rgba = ctx.getImageData(0, 0, cols, rows).data;
    const brightness = new Uint8Array(cols * rows);
    for (let p = 0; p < cols * rows; p++) {
      const r = rgba[p * 4], g = rgba[p * 4 + 1], b = rgba[p * 4 + 2];
      brightness[p] = Math.round(0.299 * r + 0.587 * g + 0.114 * b);
    }
    frames.push(brightness);

    if (onProgress) onProgress(i + 1, totalFrames);
    // Yield to keep UI responsive
    await new Promise(r => setTimeout(r, 0));
  }

  URL.revokeObjectURL(url);
  return { frames, fps: actualFps };
}

/**
 * Get video dimensions and duration from metadata.
 */
function getVideoDimensions(file) {
  return new Promise((resolve, reject) => {
    const video = document.createElement("video");
    video.preload = "metadata";
    video.onloadedmetadata = () => {
      resolve({
        width: video.videoWidth,
        height: video.videoHeight,
        duration: video.duration,
      });
      URL.revokeObjectURL(video.src);
    };
    video.onerror = () => { URL.revokeObjectURL(video.src); reject(new Error("Cannot read video")); };
    video.src = URL.createObjectURL(file);
  });
}

/**
 * Map brightness bytes to ASCII text.
 */
function brightnessToAscii(brightness, cols, rows) {
  const lines = [];
  for (let row = 0; row < rows; row++) {
    let line = "";
    for (let col = 0; col < cols; col++) {
      const b = brightness[row * cols + col];
      const idx = Math.floor(b * 9 / 255);
      line += ASCII_RAMP[idx];
    }
    lines.push(line);
  }
  return lines.join("\n");
}

/**
 * Build single-frame .blob: 4-byte header + brightness bytes.
 */
function buildSingleBlob(brightness, cols, rows) {
  const buffer = new ArrayBuffer(4 + brightness.length);
  const view = new DataView(buffer);
  view.setUint16(0, cols, true);
  view.setUint16(2, rows, true);
  new Uint8Array(buffer, 4).set(brightness);
  return new Blob([buffer], { type: "application/octet-stream" });
}

/**
 * Build animated .blob: 8-byte header + all frame bytes.
 */
function buildAnimatedBlob(frames, cols, rows, fps) {
  const frameSize = cols * rows;
  const buffer = new ArrayBuffer(8 + frameSize * frames.length);
  const view = new DataView(buffer);
  view.setUint16(0, cols, true);
  view.setUint16(2, rows, true);
  view.setUint16(4, frames.length, true);
  view.setUint16(6, fps, true);
  const body = new Uint8Array(buffer, 8);
  for (let i = 0; i < frames.length; i++) {
    body.set(frames[i], i * frameSize);
  }
  return new Blob([buffer], { type: "application/octet-stream" });
}

/**
 * Trigger a browser file download.
 */
function triggerDownload(blob, filename) {
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

// ============================================================
// UI LOGIC
// ============================================================

let currentMode = "image";
let selectedFile = null;
let sourceWidth = 0, sourceHeight = 0, aspectRatio = 0;

const dropZone = document.getElementById("dropZone");
const fileInput = document.getElementById("fileInput");
const dropText = document.getElementById("dropText");
const dropFile = document.getElementById("dropFile");
const previewBtn = document.getElementById("previewBtn");
const convertBtn = document.getElementById("convertBtn");
const statusEl = document.getElementById("status");
const previewContainer = document.getElementById("previewContainer");
const previewText = document.getElementById("previewText");
const previewInfo = document.getElementById("previewInfo");
const sourceInfoEl = document.getElementById("sourceInfo");
const colsInput = document.getElementById("cols");
const rowsInput = document.getElementById("rows");
const lockAspect = document.getElementById("lockAspect");

const IMAGE_ACCEPT = ".png,.jpg,.jpeg,.bmp,.tiff,.tif,.webp";
const VIDEO_ACCEPT = ".mp4,.webm,.mov,.gif";

// --- Aspect Ratio ---

function setSourceDimensions(w, h, extraInfo) {
  sourceWidth = w; sourceHeight = h; aspectRatio = w / h;
  let info = `Source: <span>${w} x ${h}</span> px`;
  if (extraInfo) info += ` &nbsp;|&nbsp; ${extraInfo}`;
  sourceInfoEl.innerHTML = info;
  sourceInfoEl.classList.add("show");
  applyAspectToRows();
}

function clearSourceDimensions() {
  sourceWidth = 0; sourceHeight = 0; aspectRatio = 0;
  sourceInfoEl.classList.remove("show");
}

function applyAspectToRows() {
  if (aspectRatio <= 0) return;
  const cols = parseInt(colsInput.value) || 100;
  rowsInput.value = Math.max(1, Math.round(cols / aspectRatio));
}

function applyAspectToCols() {
  if (aspectRatio <= 0) return;
  const rows = parseInt(rowsInput.value) || 60;
  colsInput.value = Math.max(1, Math.round(rows * aspectRatio));
}

colsInput.addEventListener("input", () => { if (lockAspect.checked && aspectRatio > 0) applyAspectToRows(); });
rowsInput.addEventListener("input", () => { if (lockAspect.checked && aspectRatio > 0) applyAspectToCols(); });
lockAspect.addEventListener("change", () => { if (lockAspect.checked && aspectRatio > 0) applyAspectToRows(); });

// --- Image dimensions (client-side) ---

function detectImageDimensions(file) {
  return new Promise((resolve) => {
    const img = new Image();
    img.onload = () => { resolve({ width: img.naturalWidth, height: img.naturalHeight }); URL.revokeObjectURL(img.src); };
    img.onerror = () => { resolve(null); URL.revokeObjectURL(img.src); };
    img.src = URL.createObjectURL(file);
  });
}

// --- Mode switching ---

function switchMode(mode) {
  currentMode = mode;
  document.querySelectorAll(".tab").forEach(t => t.classList.toggle("active", t.dataset.mode === mode));
  const isVideo = mode === "video";
  document.getElementById("fpsGroup").style.display = isVideo ? "" : "none";
  document.getElementById("maxFramesGroup").style.display = isVideo ? "" : "none";
  fileInput.accept = isVideo ? VIDEO_ACCEPT : IMAGE_ACCEPT;
  clearFile();
  hideStatus();
  previewContainer.classList.remove("show");
  dropText.textContent = isVideo
    ? "Drag & drop a video or GIF here, or click to browse"
    : "Drag & drop an image here, or click to browse";
}

function clearFile() {
  selectedFile = null;
  dropFile.textContent = "";
  dropZone.classList.remove("has-file");
  previewBtn.disabled = true;
  convertBtn.disabled = true;
  fileInput.value = "";
  clearSourceDimensions();
}

async function setFile(file) {
  selectedFile = file;
  dropFile.textContent = file.name + " (" + formatSize(file.size) + ")";
  dropZone.classList.add("has-file");
  previewBtn.disabled = false;
  convertBtn.disabled = false;

  if (currentMode === "image") {
    const dims = await detectImageDimensions(file);
    if (dims) setSourceDimensions(dims.width, dims.height);
  } else {
    try {
      showStatusHTML('<span class="spinner"></span> Reading video info...', "info");
      const info = await getVideoDimensions(file);
      hideStatus();
      const estFps = 24;
      const estFrames = Math.floor(info.duration * estFps);
      const extra = `~<span>${info.duration.toFixed(1)}</span>s | ~<span>${estFrames}</span> frames at 24 fps`;
      setSourceDimensions(info.width, info.height, extra);
    } catch {
      hideStatus();
    }
  }
}

function formatSize(bytes) {
  if (bytes < 1024) return bytes + " B";
  if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + " KB";
  return (bytes / (1024 * 1024)).toFixed(1) + " MB";
}

// --- Drop zone events ---

dropZone.addEventListener("click", () => {
  fileInput.accept = currentMode === "video" ? VIDEO_ACCEPT : IMAGE_ACCEPT;
  fileInput.click();
});
fileInput.addEventListener("change", (e) => {
  if (e.target.files.length > 0) { setFile(e.target.files[0]); previewContainer.classList.remove("show"); }
});
dropZone.addEventListener("dragover", (e) => { e.preventDefault(); dropZone.classList.add("drag-over"); });
dropZone.addEventListener("dragleave", () => { dropZone.classList.remove("drag-over"); });
dropZone.addEventListener("drop", (e) => {
  e.preventDefault(); dropZone.classList.remove("drag-over");
  if (e.dataTransfer.files.length > 0) { setFile(e.dataTransfer.files[0]); previewContainer.classList.remove("show"); }
});

// --- Status ---

function showStatus(msg, type) { statusEl.textContent = msg; statusEl.className = "status show " + type; }
function showStatusHTML(html, type) { statusEl.innerHTML = html; statusEl.className = "status show " + type; }
function hideStatus() { statusEl.className = "status"; }

function getParams() {
  return {
    cols: parseInt(colsInput.value) || 100,
    rows: parseInt(rowsInput.value) || 60,
    fps: parseInt(document.getElementById("fps").value) || 0,
    maxFrames: parseInt(document.getElementById("maxFrames").value) || 0,
  };
}

// --- Preview ---

async function doPreview() {
  if (!selectedFile) return;
  const params = getParams();
  const cols = Math.max(1, Math.min(params.cols, 500));
  const rows = Math.max(1, Math.min(params.rows, 500));

  previewBtn.disabled = true;
  showStatusHTML('<span class="spinner"></span> Generating preview...', "info");

  try {
    let brightness;
    if (currentMode === "video") {
      brightness = await extractVideoFrame(selectedFile, cols, rows, 0);
    } else {
      brightness = await extractBrightness(selectedFile, cols, rows);
    }

    previewText.textContent = brightnessToAscii(brightness, cols, rows);
    previewInfo.textContent = cols + "x" + rows;
    previewContainer.classList.add("show");
    requestAnimationFrame(fixPreviewAspect);
    hideStatus();
  } catch (e) {
    showStatus("Error: " + e.message, "error");
  }
  previewBtn.disabled = false;
}

// --- Convert & Download ---

async function doConvert() {
  if (!selectedFile) return;
  const params = getParams();
  const cols = Math.max(1, Math.min(params.cols, 500));
  const rows = Math.max(1, Math.min(params.rows, 500));

  convertBtn.disabled = true;
  previewBtn.disabled = true;

  try {
    let blob, filename;

    if (currentMode === "image") {
      showStatusHTML('<span class="spinner"></span> Converting image...', "info");
      const brightness = await extractBrightness(selectedFile, cols, rows);
      blob = buildSingleBlob(brightness, cols, rows);
      filename = "ascii_data.blob";
    } else {
      const fps = params.fps > 0 ? params.fps : 24;
      const maxFrames = params.maxFrames > 0 ? params.maxFrames : 0;

      const { frames, fps: actualFps } = await extractVideoFrames(
        selectedFile, cols, rows, fps, maxFrames,
        (current, total) => {
          const pct = Math.round(current / total * 100);
          showStatusHTML(
            `<div class="progress-bar"><div class="progress-fill" style="width:${pct}%"></div></div>`
            + `<span class="spinner"></span> Extracting frame ${current} / ${total}...`,
            "info"
          );
        }
      );

      if (frames.length === 0) {
        showStatus("Error: No frames extracted", "error");
        return;
      }

      showStatusHTML('<span class="spinner"></span> Building blob...', "info");
      blob = buildAnimatedBlob(frames, cols, rows, actualFps);
      filename = "ascii_sequence.blob";
    }

    triggerDownload(blob, filename);
    showStatus("Done! Downloaded " + filename + " (" + formatSize(blob.size) + ")", "success");
  } catch (e) {
    showStatus("Error: " + e.message, "error");
  }

  convertBtn.disabled = false;
  previewBtn.disabled = false;
}

// --- Preview aspect ratio fix ---

function fixPreviewAspect() {
  const measure = document.createElement("span");
  measure.style.fontFamily = getComputedStyle(previewText).fontFamily;
  measure.style.fontSize = getComputedStyle(previewText).fontSize;
  measure.style.lineHeight = getComputedStyle(previewText).lineHeight;
  measure.style.letterSpacing = getComputedStyle(previewText).letterSpacing;
  measure.style.position = "absolute";
  measure.style.visibility = "hidden";
  measure.style.whiteSpace = "pre";
  measure.textContent = "M";
  document.body.appendChild(measure);
  const charWidth = measure.getBoundingClientRect().width;
  const charHeight = measure.getBoundingClientRect().height;
  document.body.removeChild(measure);
  if (charHeight > 0 && charWidth > 0) {
    const ratio = charWidth / charHeight;
    previewText.style.transformOrigin = "top left";
    previewText.style.transform = `scaleY(${ratio})`;
    const previewContent = previewText.parentElement;
    previewContent.style.height = (previewText.scrollHeight * ratio + 16) + "px";
  }
}

// Initialize
switchMode("image");
</script>

</body>
</html>
